// BackTrack - Enhanced 3D Orbit Hero Animation
// Stunning visual effects with particles, trails, and dynamic connections

(function () {
  const container = document.querySelector('.hero-visual');
  if (!container) return;

  container.innerHTML = '';

  const canvas = document.createElement('canvas');
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.display = 'block';
  canvas.setAttribute('aria-hidden', 'true');
  container.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  let w = 0;
  let h = 0;
  let cx = 0;
  let cy = 0;
  let dpr = 1;
  let time = 0;
  let animationId = null;
  let nodes = [];
  let particles = [];
  let themeKey = '';
  let background = null;

  const mouse = { x: 0.5, y: 0.5, targetX: 0.5, targetY: 0.5 };

  function clamp(val, min, max) {
    return Math.min(max, Math.max(min, val));
  }

  function parseColor(value, fallback) {
    const raw = (value || '').trim() || fallback;
    if (!raw) return { r: 37, g: 99, b: 235 };
    if (raw.startsWith('#')) {
      let hex = raw.slice(1);
      if (hex.length === 3) {
        hex = hex.split('').map(ch => ch + ch).join('');
      }
      const intVal = parseInt(hex, 16);
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255
      };
    }
    if (raw.startsWith('rgb')) {
      const parts = raw.match(/\d+\.?\d*/g) || [];
      return {
        r: Number(parts[0] || 0),
        g: Number(parts[1] || 0),
        b: Number(parts[2] || 0)
      };
    }
    return parseColor(fallback, '#2563eb');
  }

  function rgba(color, alpha) {
    return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
  }

  function mix(a, b, t) {
    return {
      r: Math.round(a.r + (b.r - a.r) * t),
      g: Math.round(a.g + (b.g - a.g) * t),
      b: Math.round(a.b + (b.b - a.b) * t)
    };
  }

  function getTheme() {
    const style = getComputedStyle(document.body);
    const primary = parseColor(style.getPropertyValue('--accent-primary'), '#2563eb');
    const secondary = parseColor(style.getPropertyValue('--accent-secondary'), '#06b6d4');
    const bg = parseColor(style.getPropertyValue('--bg-primary'), '#000000');
    const isLight = document.body.classList.contains('light-theme');
    return {
      primary,
      secondary,
      bg,
      isLight,
      glow: isLight ? 0.3 : 0.6,
      ring: isLight ? 0.2 : 0.3,
      dot: isLight ? 0.6 : 0.85,
      particle: isLight ? 0.15 : 0.25,
      connection: isLight ? 0.08 : 0.12
    };
  }

  function buildScene() {
    const minSide = Math.min(w, h);
    const count = minSide < 520 ? 8 : 12;

    nodes = new Array(count).fill(0).map((_, i) => {
      return {
        angle: (Math.PI * 2 * i) / count,
        speed: 0.0003 + Math.random() * 0.0002,
        radius: 0.35 + Math.random() * 0.3,
        size: 2.8 + Math.random() * 2.2,
        phase: Math.random() * Math.PI * 2,
        tone: i % 3, // 3 tones for more variety
        trail: [],
        pulsePhase: Math.random() * Math.PI * 2
      };
    });

    // Create floating particles
    const particleCount = minSide < 520 ? 30 : 50;
    particles = new Array(particleCount).fill(0).map(() => {
      return {
        x: Math.random() * w,
        y: Math.random() * h,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        size: Math.random() * 1.5 + 0.5,
        opacity: Math.random() * 0.4 + 0.1,
        pulseSpeed: Math.random() * 0.002 + 0.001
      };
    });
  }

  function buildBackground(theme) {
    background = document.createElement('canvas');
    background.width = w;
    background.height = h;
    const bctx = background.getContext('2d');
    if (!bctx) return;

    // Multi-layer radial gradient
    const glow1 = bctx.createRadialGradient(cx, cy, 0, cx, cy, Math.min(w, h) * 0.4);
    glow1.addColorStop(0, rgba(mix(theme.primary, theme.secondary, 0.5), theme.glow * 0.8));
    glow1.addColorStop(0.5, rgba(theme.primary, theme.glow * 0.4));
    glow1.addColorStop(1, rgba(theme.bg, 0));
    bctx.fillStyle = glow1;
    bctx.fillRect(0, 0, w, h);

    // Outer glow layer
    const glow2 = bctx.createRadialGradient(cx, cy, Math.min(w, h) * 0.3, cx, cy, Math.min(w, h) * 0.8);
    glow2.addColorStop(0, rgba(theme.secondary, theme.glow * 0.15));
    glow2.addColorStop(0.7, rgba(mix(theme.primary, theme.secondary, 0.7), theme.glow * 0.08));
    glow2.addColorStop(1, rgba(theme.bg, 0));
    bctx.fillStyle = glow2;
    bctx.fillRect(0, 0, w, h);

    // Subtle grid pattern
    if (!theme.isLight) {
      bctx.strokeStyle = rgba(theme.primary, 0.03);
      bctx.lineWidth = 0.5;
      const gridSize = 40;
      for (let x = 0; x < w; x += gridSize) {
        bctx.beginPath();
        bctx.moveTo(x, 0);
        bctx.lineTo(x, h);
        bctx.stroke();
      }
      for (let y = 0; y < h; y += gridSize) {
        bctx.beginPath();
        bctx.moveTo(0, y);
        bctx.lineTo(w, y);
        bctx.stroke();
      }
    }
  }

  function resize() {
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    w = container.clientWidth;
    h = container.clientHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    cx = w * 0.5;
    cy = h * 0.52;
    buildScene();
    themeKey = '';
  }

  function renderFrame() {
    const theme = getTheme();
    const currentKey = `${theme.isLight}-${theme.primary.r}-${theme.primary.g}-${theme.primary.b}-${theme.secondary.r}-${theme.secondary.g}-${theme.secondary.b}-${theme.bg.r}-${theme.bg.g}-${theme.bg.b}-${w}-${h}`;
    if (currentKey !== themeKey || !background) {
      themeKey = currentKey;
      buildBackground(theme);
    }

    ctx.clearRect(0, 0, w, h);
    if (background) ctx.drawImage(background, 0, 0, w, h);

    mouse.x += (mouse.targetX - mouse.x) * 0.08;
    mouse.y += (mouse.targetY - mouse.y) * 0.08;

    const parallaxX = (mouse.x - 0.5) * w * 0.06;
    const parallaxY = (mouse.y - 0.5) * h * 0.06;

    const minSide = Math.min(w, h);
    const baseRadius = minSide * 0.28;

    // Update and render floating particles
    particles.forEach(particle => {
      particle.x += particle.vx;
      particle.y += particle.vy;

      // Wrap around edges
      if (particle.x < 0) particle.x = w;
      if (particle.x > w) particle.x = 0;
      if (particle.y < 0) particle.y = h;
      if (particle.y > h) particle.y = 0;

      // Pulse effect
      const pulse = Math.sin(time * particle.pulseSpeed) * 0.3 + 0.7;

      const gradient = ctx.createRadialGradient(
        particle.x + parallaxX * 0.3,
        particle.y + parallaxY * 0.3,
        0,
        particle.x + parallaxX * 0.3,
        particle.y + parallaxY * 0.3,
        particle.size * 3
      );
      gradient.addColorStop(0, rgba(mix(theme.primary, theme.secondary, Math.random()), particle.opacity * pulse));
      gradient.addColorStop(1, rgba(theme.bg, 0));

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(particle.x + parallaxX * 0.3, particle.y + parallaxY * 0.3, particle.size * 3, 0, Math.PI * 2);
      ctx.fill();
    });

    // Pulsing center core
    const corePulse = Math.sin(time * 0.001) * 0.3 + 0.7;
    const coreGradient = ctx.createRadialGradient(
      cx + parallaxX * 0.1,
      cy + parallaxY * 0.1,
      0,
      cx + parallaxX * 0.1,
      cy + parallaxY * 0.1,
      baseRadius * 0.15 * corePulse
    );
    coreGradient.addColorStop(0, rgba(mix(theme.primary, theme.secondary, 0.5), 0.6));
    coreGradient.addColorStop(0.5, rgba(theme.primary, 0.3));
    coreGradient.addColorStop(1, rgba(theme.primary, 0));
    ctx.fillStyle = coreGradient;
    ctx.beginPath();
    ctx.arc(cx + parallaxX * 0.1, cy + parallaxY * 0.1, baseRadius * 0.15 * corePulse, 0, Math.PI * 2);
    ctx.fill();

    // Enhanced orbit rings with rotation
    ctx.save();
    ctx.translate(cx + parallaxX * 0.2, cy + parallaxY * 0.2);
    ctx.rotate(time * 0.0001);

    // Multiple rings at different angles
    const rings = [
      { radiusX: 1.15, radiusY: 0.7, rotation: -0.4, dash: [8, 12], alpha: theme.ring * 1.2 },
      { radiusX: 0.9, radiusY: 0.55, rotation: 0.2, dash: [6, 10], alpha: theme.ring },
      { radiusX: 0.65, radiusY: 0.4, rotation: -0.1, dash: [4, 8], alpha: theme.ring * 0.8 }
    ];

    rings.forEach((ring, i) => {
      const color = i % 2 === 0 ? theme.primary : theme.secondary;
      ctx.strokeStyle = rgba(color, ring.alpha);
      ctx.lineWidth = 1.5;
      ctx.setLineDash(ring.dash);
      ctx.beginPath();
      ctx.ellipse(0, 0, baseRadius * ring.radiusX, baseRadius * ring.radiusY, ring.rotation, 0, Math.PI * 2);
      ctx.stroke();
    });

    ctx.setLineDash([]);
    ctx.restore();

    // Calculate node positions and store in array for connection lines
    const nodePositions = [];
    nodes.forEach((node, i) => {
      const angle = node.angle + time * node.speed;
      const bob = Math.sin(time * 0.001 + node.phase) * 8;
      const x = cx + Math.cos(angle) * baseRadius * node.radius + parallaxX + bob;
      const y = cy + Math.sin(angle) * baseRadius * node.radius * 0.7 + parallaxY * 0.8;

      nodePositions.push({ x, y, node, index: i });

      // Trail effect
      node.trail.unshift({ x, y, time: time });
      if (node.trail.length > 8) node.trail.pop();
    });

    // Draw connection lines between nearby nodes
    ctx.lineWidth = 1;
    for (let i = 0; i < nodePositions.length; i++) {
      for (let j = i + 1; j < nodePositions.length; j++) {
        const pos1 = nodePositions[i];
        const pos2 = nodePositions[j];
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const maxDist = baseRadius * 0.8;

        if (dist < maxDist) {
          const alpha = (1 - dist / maxDist) * theme.connection;
          const mixRatio = (pos1.index + pos2.index) % 3 / 2;
          const lineColor = mix(theme.primary, theme.secondary, mixRatio);

          const gradient = ctx.createLinearGradient(pos1.x, pos1.y, pos2.x, pos2.y);
          gradient.addColorStop(0, rgba(lineColor, alpha));
          gradient.addColorStop(0.5, rgba(lineColor, alpha * 1.5));
          gradient.addColorStop(1, rgba(lineColor, alpha));

          ctx.strokeStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(pos1.x, pos1.y);
          ctx.lineTo(pos2.x, pos2.y);
          ctx.stroke();
        }
      }
    }

    // Draw trails and nodes
    nodePositions.forEach(({ x, y, node }) => {
      // Draw trail
      if (node.trail.length > 1) {
        for (let i = 0; i < node.trail.length - 1; i++) {
          const t1 = node.trail[i];
          const t2 = node.trail[i + 1];
          const trailAlpha = (1 - i / node.trail.length) * 0.3;
          const trailColor = node.tone === 0 ? theme.primary : node.tone === 1 ? theme.secondary : mix(theme.primary, theme.secondary, 0.5);

          ctx.strokeStyle = rgba(trailColor, trailAlpha);
          ctx.lineWidth = (node.size / 2) * (1 - i / node.trail.length);
          ctx.beginPath();
          ctx.moveTo(t1.x, t1.y);
          ctx.lineTo(t2.x, t2.y);
          ctx.stroke();
        }
      }

      // Pulsing effect for nodes
      const nodePulse = Math.sin(time * 0.002 + node.pulsePhase) * 0.2 + 1;
      const dotSize = (node.size + (node.tone === 1 ? 1.8 : 0)) * nodePulse;
      const glowSize = dotSize * 6;
      const dotColor = node.tone === 0 ? theme.primary : node.tone === 1 ? theme.secondary : mix(theme.primary, theme.secondary, 0.5);

      // Multi-layer glow
      const innerGlow = ctx.createRadialGradient(x, y, 0, x, y, glowSize * 0.5);
      innerGlow.addColorStop(0, rgba(dotColor, theme.dot * 0.9));
      innerGlow.addColorStop(1, rgba(dotColor, 0));
      ctx.fillStyle = innerGlow;
      ctx.beginPath();
      ctx.arc(x, y, glowSize * 0.5, 0, Math.PI * 2);
      ctx.fill();

      const outerGlow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
      outerGlow.addColorStop(0, rgba(dotColor, theme.dot * 0.5));
      outerGlow.addColorStop(0.5, rgba(dotColor, theme.dot * 0.2));
      outerGlow.addColorStop(1, rgba(dotColor, 0));
      ctx.fillStyle = outerGlow;
      ctx.beginPath();
      ctx.arc(x, y, glowSize, 0, Math.PI * 2);
      ctx.fill();

      // Core dot with rim
      ctx.fillStyle = rgba(dotColor, theme.dot + 0.15);
      ctx.beginPath();
      ctx.arc(x, y, dotSize, 0, Math.PI * 2);
      ctx.fill();

      // Bright center
      ctx.fillStyle = rgba({ r: 255, g: 255, b: 255 }, 0.8);
      ctx.beginPath();
      ctx.arc(x, y, dotSize * 0.4, 0, Math.PI * 2);
      ctx.fill();
    });

    // Rotating sweep arcs
    ctx.save();
    ctx.translate(cx + parallaxX * 0.25, cy + parallaxY * 0.25);
    ctx.rotate(time * 0.0006);

    const sweepGrad = ctx.createRadialGradient(0, 0, baseRadius * 0.5, 0, 0, baseRadius * 1.3);
    sweepGrad.addColorStop(0, rgba(theme.primary, 0));
    sweepGrad.addColorStop(0.7, rgba(mix(theme.primary, theme.secondary, 0.5), theme.isLight ? 0.25 : 0.35));
    sweepGrad.addColorStop(1, rgba(theme.secondary, 0));
    ctx.strokeStyle = sweepGrad;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(0, 0, baseRadius * 1.08, -0.4, 0.6);
    ctx.stroke();

    // Counter-rotating arc
    ctx.rotate(-time * 0.0004);
    const sweepGrad2 = ctx.createRadialGradient(0, 0, baseRadius * 0.3, 0, 0, baseRadius * 0.9);
    sweepGrad2.addColorStop(0, rgba(theme.secondary, 0));
    sweepGrad2.addColorStop(0.7, rgba(theme.primary, theme.isLight ? 0.2 : 0.3));
    sweepGrad2.addColorStop(1, rgba(theme.primary, 0));
    ctx.strokeStyle = sweepGrad2;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, baseRadius * 0.75, 0.5, 1.8);
    ctx.stroke();

    ctx.restore();
  }

  function animate() {
    const motionDisabled = window.__DISABLE_ANIMATIONS__ ||
      (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);

    if (motionDisabled) {
      time = 2000;
      renderFrame();
      return;
    }

    time += 16;
    renderFrame();
    animationId = requestAnimationFrame(animate);
  }

  container.addEventListener('mousemove', (e) => {
    const rect = container.getBoundingClientRect();
    mouse.targetX = clamp((e.clientX - rect.left) / rect.width, 0, 1);
    mouse.targetY = clamp((e.clientY - rect.top) / rect.height, 0, 1);
  });

  container.addEventListener('mouseleave', () => {
    mouse.targetX = 0.5;
    mouse.targetY = 0.5;
  });

  container.addEventListener('touchmove', (e) => {
    const rect = container.getBoundingClientRect();
    const touch = e.touches[0];
    if (!touch) return;
    mouse.targetX = clamp((touch.clientX - rect.left) / rect.width, 0, 1);
    mouse.targetY = clamp((touch.clientY - rect.top) / rect.height, 0, 1);
  }, { passive: true });

  window.addEventListener('resize', () => {
    resize();
    renderFrame();
  });

  window.addEventListener('beforeunload', () => {
    if (animationId) cancelAnimationFrame(animationId);
  });

  resize();
  animate();
})();
